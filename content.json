{"pages":[],"posts":[{"title":"从 Kolmogorov 复杂度到 Martin Löf 随机性检验（上）","text":"Per Martin-Löf, The Definition of Random Sequences, Information and Control, 9, 602-619(1966) 考虑一个在有限字母表中所有字符串的集合。记字符串 \\(x = \\xi_1\\xi_2\\dots\\xi_n\\) 的长度 \\(l(x) = n\\)。接下来我们需要考虑的问题是，这个序列有多复杂？ 很显然，直观地讲，一个“随机”（我们很快会回到这一点上来）字符串要比一个有规律的字符串复杂地多。同样很直观地，我们可以把一个字符串的复杂度定义为某种“最简单的描述方法的长度”，Kolmogorov 算术复杂度就是从这个视角出发做出的形式化定义。 “描述方法”和 Kolmogorov-Solomonoff 定理 接下来我们需要反思，“描述方法”应该如何被形式化地定义出来？既然本文的 tag 中带有计算理论，很自然的一种想法就是，“描述方法”就是一种算法。 在这里，我们使用“算法”这个概念来表达一种从一个有限二进制序列到一个有限字母表上的单子的映射。算法概念的更精确的形式化定义可以采用递归论的定义模式或者其他等价的形式（本文中将不再展开），这并不影响后文的探讨。 记 \\(A\\) 为一种算法，\\(A(p) = x\\)，\\(p\\) 为一个有限二进制串，\\(x\\) 为一个有限字母表上的字符串，我们称 \\(p\\) 是在算法 \\(A\\) 下对 \\(x\\) 的描述。接下来，延续我们前面的直观认识，我们可以定义相对于算法 \\(A\\) 字符串 \\(x\\) 的复杂度为： \\[ K_A(x) = \\min\\limits_{A(p) = x}(l(p)) \\] 那么，很自然的一个问题是，是否一定存在这样的二进制串 \\(p\\) 来对任意字符串 \\(x\\) 做出描述？答案是否定的。只要考虑一个平凡的算法 \\(A_0\\)，它将任意二进制串 \\(p\\) 都映射到字符串 \\(x_0\\)，那么，其他的字符串就都不能在这个算法下做出描述。因此，为了定义的严谨性，我们需要补充说明： \\[ K_A(x) = + \\infty, \\mathrm{if}\\ \\forall p, A(p) \\neq x \\] 现在，我们剩下的一个问题就是，我们不能摆脱算法 \\(A\\) 对我们的定义的限制。我们在考虑一个序列的复杂度时，很显然不是要考虑一个字符串“在某种描述方法下”的复杂度，我们需要使得它成为一个只与字符串 \\(x\\) 有关的数。为了实现这个定义，就需要引入 Kolmogorov-Solomonoff 定理： 存在一个算法 \\(A\\)，使得对于任意算法 \\(B\\)， \\[ K_A(x) \\leqslant K_B(x) + c \\] 其中 \\(c\\) 为一常数，且其只与 \\(A\\) 和 \\(B\\) 有关。 这个算法在 Kolmogorov 的著作中被称为渐进最优的（asymptotically optimal），在 Solomonoff 的著作中被称为通用的（universial），上述定理的证明如果我不鸽的话会丢进本文的附录或者其他文章里。总之，现在我们已经有了一个最好的算法来讨论如何描述字符串 \\(x\\)，于是，我们就可以定义这个字符串的复杂度 \\(K(x) = K_A(x)\\)，称其为 Kolmogorov 复杂度，或者简单地称为复杂度。 同样地，我们可以引入条件复杂度的概念。考虑一个两变量的算法 \\(A(p, x)\\)，\\(x\\) 为一个有限字母表上的字符串，若 \\(A(p, x) = y\\)，则我们将其称为在 \\(x\\) 的条件下对（可能不同于 \\(x\\) 的）字母表上的字符串 \\(y\\) 的描述。称在 \\(x\\) 的条件下相对于算法 \\(A\\) 的 \\(y\\) 的复杂度为： \\[ K_A(y \\vert x) = \\min\\limits_{A(p, x) = y}(l(p)) \\] 这个定义也是很自然的，同样与上面的讨论和我们的直观感受匹配。幸运地是，亲爱的 Kolmogorov 先生同样给出了一个与上面的定理相对应的定理： 存在一个算法 \\(A\\)，使得对于任意算法 \\(B\\)， \\[ K_A(y \\vert x) \\leqslant K_B(y \\vert x) + c \\] 其中 \\(c\\) 为一常数，且其只与 \\(A\\) 和 \\(B\\) 有关。 因此，我们也记 \\(K(y\\vert x) = K_A(y \\vert x)\\)，并称其为在 \\(x\\) 的条件下 \\(y\\) 的条件复杂度。 很直观的，对于任意长度为 \\(n\\) 的二进制串 \\(x\\)，都有 \\[ K(x \\vert n) \\leqslant n + c \\] 其中 \\(n\\) 是用于描述这个字符串所用的最多比特数，在最坏情况下，我们需要将整个串都硬编码到代码当中，那么当然需要 \\(n\\) 的长度。而 \\(c\\) 则是机器相关的常数。 同时，我们可以尝试给出一个下界，满足 \\[ K(\\xi_1\\xi_2\\dots\\xi_n \\vert n) \\geqslant n - c \\] 的序列一共有 \\((1-2^{-c})2^n\\) 个。这个结论也很平凡，留给读者自证。 于是，我们发现，当 \\(n\\) 很大的时候，会有很多字符串的复杂度的渐进上界是在 \\(O(n)\\) 这个最大的级别的。Kolmogorov 指出，这可以使我们形式化地定义一个字符串的随机性。 一些评述 看起来，对于二元算法的定义事实上意义不是很大，因为 \\(n\\) 同样可以以 \\(\\log n\\) 的复杂度编写到程序之中，这对于我们的结果并没有影响。事实上，很多较现代的论文提供了另外一种定义形式，例如 Peter D. Grünwald and Paul M. B. Vitányi, Algorithmic Information Theory 中给出的定义是： \\[ K(x) = \\min\\limits_{y, p: p(y) = x}(l(p) + l(y)) \\] 这种定义形式似乎更加符合我们的预期。另外，也将一个对象的 Kolmogorov 编码定义为 \\(E*(x)\\)，是最短的能够打印 \\(x\\) 然后停下的代码。 在这种定义形式下，我们就可以给出三种分类： 简单的对象：\\(O(\\log n)\\)，其原因已经在前面解释过了，因为 \\(n\\) 需要被硬编码进去 完全偶然对象（completely random objects）：\\(n + O(\\log n)\\)，也是显然的 随机对象（stochastic objects）：\\(\\alpha n + o(n)\\) 如果 \\(x_i\\) 是一个随机变量 \\(X_i\\) 的实现，其分布为 \\(P\\)，则这个对象是随机的，其中 \\(\\alpha &lt; 1\\)。比较常见的例子是二项分布，其 \\(\\alpha = H(p)\\) 为二值熵（binary entrophy） \\[ H(p) = -p\\log p - (1-p) \\log(1-p) \\] 随机对象的情形可以类比于扔一个有缺陷的硬币，硬币的缺陷使得这个序列不再成为完全随机的，当然，很显然，\\(p = 0.5\\) 时， \\(H(p) = 1\\)，序列还是完全偶然的。 另一个很遗憾的问题是，\\(K(x)\\) 不是可计算的，在 [Li and Vitányi, 1997] 中，他们表明它是上半可计算的（upper semicomputable），或者简单地理解就是，它是可以被近似的，但近似算法很慢，且不能确定其终点。但是，也有一些方式来解决这个问题，比如通用编码（[Cover and Thomas, 1991]），最小描述长度原理（MDL, [Solomonoff, 1997]）等方式的近似。 Blum 和 Burgin 的公理系统对于这个领域来说也是相当重要的，他们给出了关于这些性质的普遍描述，如果不鸽的话大概也会专门开一篇文章来介绍他们的成果，嗯，如果不鸽的话。","link":"/blog/2022/06/27/Kolmogorov-and-Martin-Lof01/"},{"title":"量子编程（Maksim Dimitrijev） Lecture 1","text":"在近二十年间，出现了两种量子计算的主要范式。一种是量子门编程模型（gate-based model of quantum computing），也叫通用量子计算（universal quantum computing）；另一种是量子退火方法（quantum annealing），也叫绝热量子计算（adiabatic quantum computing）。从数学角度上看，这两种模型具备同等的计算能力，但在实践上，两者有显著的不同。 前两次讲座主要介绍量子门编程模型，第一次讲座的内容包括量子比特（quantum bits, qubits）和量子门（quantum gates）、以及量子电路（quantum circuits）。 量子比特和量子门 正如经典计算机一样，量子计算机也一样由门电路构成，不过其用来表示信息的单元为量子比特而非高低电平，其运算模块为量子门而非数字电路的逻辑门。 单个的量子比特 单个量子比特为计算的基本单元，处在 \\(0\\) 和 \\(1\\) 的叠加状态（superposition）之中。我们可以使用类似描述振幅的方式去描述一个量子比特 \\(|\\psi\\rangle\\)： \\[ |\\psi\\rangle = \\psi_0|0\\rangle + \\psi_1|1\\rangle = \\big ( \\begin{matrix} \\psi_0 \\\\ \\psi_1 \\end{matrix} \\big ) \\] 其中 \\(\\psi_0\\) 和 \\(\\psi_1\\) 均为复数。可以将 \\(|0\\rangle\\) 和 \\(|1\\rangle\\) 理解成一组基： \\[ |0\\rangle = \\begin{bmatrix} 1 \\newline 0 \\end{bmatrix} \\newline |1\\rangle = \\begin{bmatrix} 0 \\newline 1 \\end{bmatrix} \\] 这两个复数需要满足归一化条件： \\[ \\langle \\psi \\vert \\psi \\rangle = |\\psi_0|^2 + |\\psi_1|^2 = 1 \\] 因此，我们可以表明， \\[ \\exists \\theta \\in [0, \\pi], \\mathrm{s. t.} |\\psi_0| = \\cos \\frac{\\theta}{2}, |\\psi_1| = \\sin \\frac{\\theta}{2} \\] 因为全局相位对其状态无影响，我们可以不失一般性地令 \\[ \\psi_0 = \\cos \\frac \\theta 2 \\newline \\psi_1 = e^{i\\phi}\\sin \\frac \\theta 2 \\] 其中 \\(\\phi \\in [0, 2\\pi)\\) 表示复系数之间的相对相位。 基于这些特性，我们可以在 Bloch 球面中表达一个量子比特，如下图： 其中的 \\(r^x, r^y, r^z\\) 可以以投影的方式给出： \\[ \\mathbf r = \\begin{bmatrix} r^x \\newline r^y \\newline r^z \\end{bmatrix} = \\begin{bmatrix} \\sin\\theta\\cos\\phi \\newline \\sin\\theta\\sin\\phi \\newline \\cos\\theta \\end{bmatrix} = \\begin{bmatrix} \\langle\\psi|\\sigma^x|\\psi\\rangle \\newline \\langle \\psi|\\sigma^y|\\psi\\rangle \\newline \\langle \\psi|\\sigma^z|\\psi\\rangle \\newline \\end{bmatrix} \\] 其中 \\(\\langle\\psi|\\sigma|\\psi\\rangle = \\vert \\psi \\rangle^H \\sigma \\vert \\psi \\rangle\\)，其中 \\(A^H\\) 表示 \\(A\\) 的共轭转置，\\(\\sigma^x\\)，\\(\\sigma^y\\)，\\(\\sigma^z\\) 为 Pauli 矩阵： \\[ \\sigma^x = \\begin{bmatrix} 0 &amp; 1 \\newline 1 &amp; 0 \\end{bmatrix}, \\sigma^y = \\begin{bmatrix} 0 &amp; -i \\newline i &amp; 0 \\end{bmatrix}, \\sigma^z = \\begin{bmatrix} 1 &amp; 0 \\newline 0 &amp; -1 \\end{bmatrix} \\] 关于 Bloch 球面，在第十讲中会有更详尽的叙述。需要注意，在进行测量时，一个量子比特会坍缩到 \\(0\\) 或者 \\(1\\) 的定态，其测量结果为 \\(0\\) 的概率为 \\(|\\psi_0|^2\\)，为 \\(1\\) 的概率为 \\(|\\psi_1|^2\\)。 量子门 量子门可以看作是对 \\(|\\psi\\rangle\\) 在 Bloch 球面上的旋转操作，事实上就是一些 \\(2 \\times 2\\) 的酉矩阵。基于 Pauli 矩阵我们可以很方便的构造出绕坐标轴旋转的 Pauli 门： \\[ R^x(\\theta) = e^{-\\frac{i\\theta\\sigma^x}{2}} = \\begin{bmatrix} \\cos \\frac \\theta 2 &amp; -i\\sin\\theta 2 \\newline -i\\sin \\frac\\theta 2 &amp; \\cos \\frac \\theta 2 \\end{bmatrix} \\newline R^y(\\theta) = e^{-\\frac{i\\theta\\sigma^y}{2}} = \\begin{bmatrix} \\cos \\frac \\theta 2 &amp; -\\sin\\theta 2 \\newline \\sin \\frac\\theta 2 &amp; \\cos \\frac \\theta 2 \\end{bmatrix} \\newline R^z(\\theta) = e^{-\\frac{i\\theta\\sigma^z}{2}} = \\begin{bmatrix} e^{-\\frac{i\\theta}{2}} &amp; 0 \\newline 0 &amp; e^{\\frac{i\\theta}{2}} \\end{bmatrix} \\newline \\] 在实际的实现中，只会实现部分基本旋转，然后将其组合起来以实现真正的旋转门。例如，IBM Q 实现了 \\(R^x(\\frac\\theta 2)\\) 和 \\(R^z(\\theta)\\)。 可以按照如下公式组合形成能够完成绕任意轴旋转的旋转门，其中 \\(\\vec n\\) 是旋转轴的单位向量： \\[ R^{\\vec n}(\\theta) = e^{-\\frac{i\\theta\\vec n\\vec \\sigma}{2}} = I\\cos\\frac \\theta 2 - in_i\\sigma^i\\sin \\frac \\theta 2 \\] 其中 \\(I\\) 为恒等矩阵，\\(i = x, y, z\\) 还有其他常用的门，罗列如下： \\[ X = \\sigma^x, Y = \\sigma^y, Z = \\sigma^z \\newline H = \\frac 1 {\\sqrt 2} \\begin{bmatrix} 1 &amp; 1 \\newline 1 -1 \\end{bmatrix}, T = \\begin{bmatrix} 1 &amp; 0 \\newline 0 &amp; e^{\\frac{i\\pi}{4}}\\end{bmatrix}, S = T^2 = \\begin{bmatrix} 1 &amp; 0 \\newline 0 &amp; i\\end{bmatrix} \\] 其中比较重要的是 \\(X\\) 门，又称 \\(NOT\\) 门、翻转门（flipping gate）；\\(H\\) 门被称为 Hadamard 门，\\(T\\) 和 \\(S\\) 为相位改变门。 多个量子比特的情形 在具备多个量子比特的情况下，只需要由 Kronecker 积（张量积，tensor product）将它们组合起来即可。我们首先构造这样一组基： \\[ |q_0q_1q_2\\dots q_{n-1}\\rangle = |q_0\\rangle \\otimes |q_1\\rangle \\otimes |q_2\\rangle \\otimes \\dots \\otimes|q_{n - 1}\\rangle \\] 其中 \\(q_i = 0, 1\\)，可以发现，\\(q_0q_1\\dots q_{n-1}\\) 是一个大小在 \\(0\\) 到 \\(2^n - 1\\) 之间的数 \\(j\\) 的二进制表示。记 \\(|q_0q_1...q_{n-1}\\rangle = |j\\rangle\\)，于是可以将一个 \\(n\\) bit 的系统表示为 \\(\\sum\\limits_{j}\\psi_j|j\\rangle\\)。 涉及多个量子比特的门同样可以用 Kronecker 积表出，记 \\(U_i\\) 为只对第 \\(i\\) 个比特做 \\(U\\) 操作的门，则： \\[ U_i = |q_0q_1\\dots q_{i-1}\\rangle U(q_i) |q_{i+1}q_{i+2}\\dots q_{n-1}\\rangle \\] 则很显然可以得出： \\[ U_i =\\underbrace{\\overbrace{I \\otimes I \\otimes \\cdots \\otimes I}^{i-1\\text{个}} \\otimes U \\otimes I \\otimes I \\cdots \\otimes I}_{n\\text{个}} \\] 当使用多个量子比特的系统时，很显然我们不只是想操作其中的某一个比特，而是要对其中的比特进行关联的操作，例如，当某比特为某状态时，对另一比特做某操作。受控的量子门（Controlled-U gate）就实现了这一点： \\[ CU_{i_1i_2}|q_0q_1\\dots q_{n-1}\\rangle = \\begin{cases} |q_0q_1\\dots q_{n-1}\\rangle, &amp; q_{i_1} = 0 \\newline |U_{i_2}|q_0q_1\\dots q_{n-1}\\rangle, &amp; q_{i_1} = 1 \\end{cases} \\] 一个暂时用不上的附注：在做 \\(CU\\) 门运算之后，全局相位会变为相对相位。 常见的多比特门如下： \\[ CNOT = \\begin{bmatrix} 1&amp;0&amp;0&amp;0\\newline 0&amp;1&amp;0&amp;0\\newline 0&amp;0&amp;0&amp;1\\newline 0&amp;0&amp;1&amp;0 \\end{bmatrix}, CZ = \\begin{bmatrix} 1&amp;0&amp;0&amp;0\\newline 0&amp;1&amp;0&amp;0\\newline 0&amp;0&amp;1&amp;0\\newline 0&amp;0&amp;0&amp;-1 \\end{bmatrix} \\] 读者不难自证，它们之间存在如下联系： \\[ CNOT = (I\\otimes H)CZ(I \\otimes H) \\] 量子电路及其编程 量子电路的结构类似下图： 上图表示的是量子电路中的一个四位半加器，最左边将几个比特初始化，从左向右依次由不同的量子门对每个比特进行处理，最终结果输出在右侧。 在实际用 Python 进行编程时，一般使用 qiskit 作为电路前端，后端模拟器有以下三种选择： qasm_simulator：初始值全 \\(0\\)，无噪声影响下的测量结果； statevector_simulator：在测量导致量子态坍缩之前的直接计算结果； unitary_simulator：给出计算过程的酉矩阵。","link":"/blog/2022/06/27/Maksim-06-27/"}],"tags":[{"name":"复杂度","slug":"复杂度","link":"/blog/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"概率论","slug":"概率论","link":"/blog/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"信息论","slug":"信息论","link":"/blog/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"},{"name":"计算理论","slug":"计算理论","link":"/blog/tags/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"},{"name":"量子计算","slug":"量子计算","link":"/blog/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/"}],"categories":[{"name":"论文笔记","slug":"论文笔记","link":"/blog/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"课程笔记","slug":"课程笔记","link":"/blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"计算理论","slug":"论文笔记/计算理论","link":"/blog/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/"},{"name":"量子算法与编程暑期讲习班","slug":"课程笔记/量子算法与编程暑期讲习班","link":"/blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E9%87%8F%E5%AD%90%E7%AE%97%E6%B3%95%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%9A%91%E6%9C%9F%E8%AE%B2%E4%B9%A0%E7%8F%AD/"},{"name":"Martin Löf(1966)","slug":"论文笔记/计算理论/Martin-Lof-1966","link":"/blog/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/Martin-Lof-1966/"},{"name":"量子编程","slug":"课程笔记/量子算法与编程暑期讲习班/量子编程","link":"/blog/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E9%87%8F%E5%AD%90%E7%AE%97%E6%B3%95%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%9A%91%E6%9C%9F%E8%AE%B2%E4%B9%A0%E7%8F%AD/%E9%87%8F%E5%AD%90%E7%BC%96%E7%A8%8B/"}]}